<!doctype html><html><head></head><body><!doctype html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Tyreese's Playlist Player</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
	<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
	<style>
		/* --- Theme Definitions --- */

		/* --- Root Variables: DRACULA (Blood Red) - DEFAULT --- */
		:root,
		.theme-dracula {
			--bg-color: #18191f;
			/* Main body background */
			--card-color: #282a36;
			/* Primary card and controls background */
			--text-color: #f8f8f2;
			/* White text */
			--bright-green: #ff5555;
			/* Blood Red for Title, Visualizer, Active Track */
			--control-orange: #ffb86c;
			/* Playback and mode buttons (Kept Orange) */
			--progress-blue: #8be9fd;
			/* Seek bar thumb/progress */
			--light-gray: #6272a4;
			/* Muted blue-gray for secondary text/inactive elements/separator */
			--dark-gray: #44475a;
			/* Interior icon block background/slider track */
			--border-radius: 12px;
			--warning-color: #ff5555;
			--settings-modal-bg: #44475a;
			--settings-shadow: rgba(0, 0, 0, 0.7);
		}

		/* --- Theme Overrides: ORIGINAL GREEN DRACULA --- */
		.theme-default {
			--bg-color: #1a1a1d;
			--card-color: #282a36;
			--text-color: #f8f8f2;
			--bright-green: #50fa7b;
			/* ORIGINAL GREEN ACCENT */
			--control-orange: #ffb86c;
			--progress-blue: #8be9fd;
			--light-gray: #6272a4;
			--dark-gray: #44475a;
			--warning-color: #ff5555;
			--settings-modal-bg: #44475a;
			--settings-shadow: rgba(0, 0, 0, 0.7);
		}

		/* --- Theme Overrides: PinkPantheress (Soft Pink) --- */
		.theme-pinkpantheress {
			--bg-color: #ffa8c0;
			/* Very light pink background */
			--card-color: #ffc0cb;
			/* Slightly more saturated pink card background */
			--text-color: #ff92a5;
			/* Dark text for readability */
			--bright-green: #ffa8c0;
			/* Hot Pink Accent (Primary color) */
			--control-orange: #d81b60;
			/* Slightly darker pink/magenta for controls */
			--progress-blue: #ff80ab;
			/* Light pink for progress */
			--light-gray: #ff5674;
			/* Muted gray for secondary */
			--dark-gray: #ff6c85;
			/* Light pink for Interior icon block background/slider track */
			--border-radius: 12px;
			--warning-color: #ff5573;
			--settings-modal-bg: #ff92a5;
			--settings-shadow: rgba(0, 0, 0, 0.2);
		}

		.theme-light {
			--bg-color: #e0e0e0;
			--card-color: #ffffff;
			--text-color: #121212;
			--bright-green: #1db954;
			--control-orange: #ff9800;
			--progress-blue: #2196f3;
			--light-gray: #666666;
			--dark-gray: #f2f2f2;
			--warning-color: #ffcc00;
			--settings-modal-bg: #f2f2f2;
			--settings-shadow: rgba(0, 0, 0, 0.2);
		}

		.theme-ocean {
			--bg-color: #0b1e42;
			/* Deep Blue */
			--card-color: #1a2a53;
			--text-color: #e0f7fa;
			/* Light Cyan */
			--bright-green: #00bcd4;
			/* Cyan Accent */
			--control-orange: #ff9800;
			/* Orange */
			--progress-blue: #4fc3f7;
			/* Light Blue */
			--light-gray: #78909c;
			/* Muted Gray-Blue */
			--dark-gray: #26324b;
			/* Darker Card Interior */
			--warning-color: #fdd835;
			--settings-modal-bg: #26324b;
			--settings-shadow: rgba(0, 0, 0, 0.5);
		}

		.theme-forest {
			--bg-color: #2b5435;
			/* Dark Forest Green */
			--card-color: #386742;
			--text-color: #f0fff0;
			/* Honeydew */
			--bright-green: #aed581;
			/* Lime Green Accent */
			--control-orange: #ffccbc;
			/* Light Peach */
			--progress-blue: #81c784;
			/* Medium Green */
			--light-gray: #9e9e9e;
			/* Muted Gray */
			--dark-gray: #4c8a5a;
			/* Darker Card Interior */
			--warning-color: #ff8a65;
			--settings-modal-bg: #4c8a5a;
			--settings-shadow: rgba(0, 0, 0, 0.5);
		}


		/* --- General Styles (Rest of CSS remains the same) --- */
		body {
			font-family: 'Roboto', sans-serif;
			background-color: var(--bg-color);
			color: var(--text-color);
			margin: 0;
			padding: 20px;
			display: flex;
			justify-content: center;
			align-items: flex-start;
			min-height: 100vh;
			transition: background-color 0.3s;
		}

		/* --- Player Container (COMPACT WIDTH) --- */
		#player-app {
			position: relative;
			width: 100%;
			max-width: 600px;
			background-color: var(--card-color);
			border-radius: var(--border-radius);
			box-shadow: 0 4px 60px rgba(0, 0, 0, 0.5);
			padding: 25px;
			transition: background-color 0.3s;
		}

		/* --- Header and Settings --- */
		#header-container {
			display: flex;
			justify-content: space-between;
			align-items: center;
		}

		h1 {
			flex-grow: 1;
			margin: 0;
			text-align: center;
			color: var(--bright-green);
			text-shadow: 0 0 5px var(--bright-green);
			font-size: 28px;
		}

		#settings-btn {
			background: none;
			border: none;
			color: var(--light-gray);
			font-size: 24px;
			cursor: pointer;
			transition: color 0.2s, transform 0.2s;
			line-height: 1;
		}

		#settings-btn:hover {
			color: var(--bright-green);
			transform: rotate(30deg);
		}

		/* Alert Banner Style */
		#file-not-found-alert {
			background-color: var(--warning-color);
			color: var(--card-color);
			padding: 10px 15px;
			margin-top: 15px;
			margin-bottom: 15px;
			border-radius: var(--border-radius);
			font-weight: 700;
			text-align: center;
			display: none;
		}

		/* --- Settings Modal Styles --- */
		#settings-modal {
			position: absolute;
			top: 60px;
			right: 25px;
			width: 250px;
			background-color: var(--settings-modal-bg);
			border-radius: var(--border-radius);
			padding: 15px;
			box-shadow: 0 4px 15px var(--settings-shadow);
			z-index: 1000;
			transform: translateX(10px);
			opacity: 0;
			visibility: hidden;
			transition: transform 0.2s ease-out, opacity 0.2s ease-out, visibility 0.2s;
			border: 1px solid var(--dark-gray);
		}

		#settings-modal.open {
			transform: translateX(0);
			opacity: 1;
			visibility: visible;
		}

		.setting-row {
			padding: 8px 0;
			font-size: 14px;
			display: flex;
			justify-content: space-between;
			align-items: center;
			border-bottom: 1px solid var(--dark-gray);
		}

		.setting-row:last-child {
			border-bottom: none;
		}

		#theme-select,
		#visualizer-mode-select,
		#skip-silence-select {
			background-color: var(--dark-gray);
			color: var(--text-color);
			border: 1px solid var(--light-gray);
			padding: 4px;
			border-radius: 4px;
			font-size: 13px;
			cursor: pointer;
		}

		/* --- End Settings Modal Styles --- */


		/* --- File Upload Area --- */
		#file-input-container {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-top: 20px;
			margin-bottom: 20px;
			align-items: center;
		}

		#mp3-upload {
			display: none;
		}

		#file-label,
		#clear-playlist-btn,
		#sort-playlist-btn {
			cursor: pointer;
			background-color: var(--dark-gray);
			color: var(--text-color);
			padding: 8px 15px;
			border-radius: 6px;
			font-size: 14px;
			transition: background-color 0.2s;
			user-select: none;
			border: 1px solid var(--dark-gray);
		}

		#file-label:hover,
		#clear-playlist-btn:hover,
		#sort-playlist-btn:hover {
			background-color: var(--light-gray);
		}

		#clear-playlist-btn:disabled,
		#sort-playlist-btn:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}

		#limit-message-wrapper {
			flex-grow: 1;
			text-align: right;
		}

		#limit-message {
			font-size: 12px;
			color: var(--light-gray);
		}


		/* --- Playlist Section --- */
		#playlist-container {
			overflow-y: auto;
			max-height: 350px;
			min-height: 100px;
			border-top: 1px dashed var(--dark-gray);
			border-bottom: 1px dashed var(--dark-gray);
			padding: 10px 0;
			margin-bottom: 20px;
		}

		#playlist {
			list-style: none;
			padding: 0;
			margin: 0;
		}

		#playlist-empty {
			padding: 20px;
			text-align: center;
			color: var(--light-gray);
			font-size: 14px;
		}

		.track-item {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 8px 15px;
			border-radius: 6px;
			margin-bottom: 4px;
			transition: background-color 0.2s, box-shadow 0.2s;
			user-select: none;
			cursor: grab;
		}

		.track-item:hover {
			background-color: var(--dark-gray);
		}

		.track-item.active {
			background-color: var(--bright-green);
			color: var(--card-color);
			font-weight: 700;
			box-shadow: 0 0 8px var(--bright-green);
			cursor: default;
		}

		.track-item.dragging {
			opacity: 0.5;
		}

		.track-item.drag-over-top {
			border-top: 3px solid var(--control-orange);
		}

		.track-item.drag-over-bottom {
			border-bottom: 3px solid var(--control-orange);
		}

		.track-item-left {
			display: flex;
			align-items: center;
			flex: 1;
			overflow: hidden;
			cursor: pointer;
		}

		.ready-indicator {
			width: 6px;
			height: 6px;
			border-radius: 50%;
			background-color: var(--warning-color);
			/* Red for missing file */
			margin-right: 10px;
			flex-shrink: 0;
		}

		.ready-indicator.ready {
			background-color: var(--bright-green);
		}

		.track-name {
			font-size: 15px;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.track-duration {
			font-size: 13px;
			color: var(--light-gray);
			flex-shrink: 0;
			margin-left: 15px;
		}

		.track-item.active .track-duration {
			color: var(--card-color);
		}

		.remove-btn {
			background: none;
			border: none;
			color: var(--light-gray);
			font-size: 16px;
			cursor: pointer;
			margin-left: 10px;
			transition: color 0.2s;
			flex-shrink: 0;
		}

		.track-item.active .remove-btn {
			color: var(--card-color);
		}

		.remove-btn:hover {
			color: var(--warning-color);
		}

		/* --- Controls Section (Media Player) --- */

		#controls-bar {
			background-color: var(--dark-gray);
			border-radius: var(--border-radius);
			padding: 20px;
		}

		#track-info-container {
			display: flex;
			align-items: center;
			gap: 20px;
			margin-bottom: 15px;
			max-width: 100%;
		}

		/* --- BIGGER ALBUM ART CONTAINER --- */
		#album-art-container {
			width: 150px;
			height: 150px;
			flex-shrink: 0;
			border-radius: 12px;
			overflow: hidden;
			box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
			background-color: var(--card-color);
		}

		#album-art {
			width: 100%;
			height: 100%;
			object-fit: cover;
		}

		#track-details {
			flex-grow: 1;
			min-width: 0;
		}

		#current-track-display {
			font-size: 22px;
			font-weight: 700;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			color: var(--text-color);
			margin-bottom: 5px;
		}

		#current-track-display.empty {
			color: var(--light-gray);
			font-style: italic;
			font-weight: 400;
		}

		.dashed-separator {
			border-bottom: 2px dashed var(--light-gray);
			opacity: 0.3;
			margin: 10px 0;
		}

		#main-control-area {
			display: flex;
			flex-direction: column;
			align-items: center;
			max-width: 100%;
		}

		/* Icon Block */
		#icon-block {
			display: flex;
			justify-content: space-between;
			align-items: center;
			background-color: var(--card-color);
			border-radius: 100px;
			padding: 15px 20px;
			margin-bottom: 15px;
			box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
			width: 100%;
			max-width: 450px;
			/* Slightly wider to accommodate new buttons */
		}

		#mode-buttons,
		#playback-buttons {
			display: flex;
			align-items: center;
			gap: 15px;
			/* Reduced gap slightly for 5 playback buttons */
		}

		#playback-buttons button,
		#mode-buttons button {
			background: none;
			border: none;
			color: var(--control-orange);
			font-size: 30px;
			cursor: pointer;
			transition: color 0.2s, transform 0.1s;
			padding: 5px;
			line-height: 1;
		}

		/* Specific style for skip buttons */
		#skip-back-btn,
		#skip-forward-btn {
			font-size: 20px;
		}


		#playback-buttons button:hover,
		#mode-buttons button:hover {
			color: var(--bright-green);
			transform: scale(1.1);
		}

		#play-pause-btn {
			font-size: 40px;
			color: var(--bright-green);
		}

		#play-pause-btn:hover {
			color: var(--control-orange);
		}

		#shuffle-btn.active,
		#repeat-btn.active {
			color: var(--bright-green);
		}

		/* Visualizer */
		#visualizer {
			display: flex;
			justify-content: space-between;
			align-items: flex-end;
			height: 30px;
			width: 100%;
			margin: 10px 0;
			gap: 2px;
			opacity: 0.8;
			position: relative;
		}

		/* Canvas for Visualizer Modes */
		#visualizer canvas {
			display: none;
			/* Hide initially, shown by JS */
			width: 100%;
			height: 100%;
			position: absolute;
			top: 0;
			left: 0;
			z-index: 10;
		}

		.visualizer-bar {
			flex-grow: 1;
			background-color: var(--bright-green);
			width: 4px;
			min-height: 1px;
			border-radius: 2px;
			transition: height 0.05s ease-out;
		}

		/* Speed Controls */
		#speed-controls {
			display: flex;
			gap: 10px;
			margin-bottom: 15px;
			width: 100%;
			max-width: 400px;
			justify-content: center;
		}

		.speed-btn {
			background-color: var(--card-color);
			color: var(--light-gray);
			border: 1px solid var(--light-gray);
			padding: 5px 10px;
			border-radius: 4px;
			font-size: 12px;
			cursor: pointer;
			transition: all 0.2s;
		}

		.speed-btn:hover {
			background-color: var(--light-gray);
			color: var(--card-color);
		}

		.speed-btn.active {
			background-color: var(--bright-green);
			color: var(--card-color);
			border-color: var(--bright-green);
			font-weight: 700;
		}

		/* Seek and Volume */
		#seek-volume-row {
			display: flex;
			align-items: center;
			gap: 20px;
			width: 100%;
		}

		#seek-bar-container {
			flex-grow: 1;
			display: flex;
			align-items: center;
			gap: 10px;
		}

		#current-time,
		#total-duration {
			font-size: 13px;
			color: var(--light-gray);
			flex-shrink: 0;
		}

		#seek-bar,
		#volume-bar {
			-webkit-appearance: none;
			appearance: none;
			height: 6px;
			background: var(--card-color);
			border-radius: 3px;
			cursor: pointer;
			flex-grow: 1;
		}

		/* Bright green/red used for the slider thumb */
		#seek-bar::-webkit-slider-thumb,
		#volume-bar::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 15px;
			height: 15px;
			border-radius: 50%;
			background: var(--bright-green);
			cursor: pointer;
			box-shadow: 0 0 5px var(--bright-green);
		}

		#seek-bar:disabled,
		#volume-bar:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}

		#volume-bar-container {
			display: flex;
			align-items: center;
			gap: 8px;
			width: 140px;
			flex-shrink: 0;
		}

		#volume-bar-container button {
			font-size: 18px;
			color: var(--text-color);
			transition: color 0.2s;
		}

		#volume-bar-container button:hover {
			color: var(--bright-green);
		}


		/* Responsive adjustments */
		@media (max-width: 500px) {
			#player-app {
				padding: 15px;
			}

			h1 {
				font-size: 24px;
			}

			#track-info-container {
				flex-direction: column;
				text-align: center;
				gap: 15px;
			}

			#album-art-container {
				width: 120px;
				height: 120px;
			}

			#current-track-display {
				text-align: center;
				font-size: 18px;
			}

			#seek-volume-row {
				flex-direction: column;
				gap: 15px;
			}

			#seek-bar-container,
			#volume-bar-container {
				width: 100%;
			}
		}
	</style>
</head>

<body class="theme-dracula">

	<div id="player-app">

		<div id="header-container">
			<h1>üéµ Tyreese's Playlist Player</h1>
			<button id="settings-btn" title="Settings">‚öôÔ∏è</button>
		</div>

		<div id="settings-modal" style="display: none;">
			<div class="setting-row">
				<span>Theme:</span>
				<select id="theme-select">
					<option value="dracula">Dracula (Blood Red)</option>
					<option value="default">Default (Green)</option>
					<option value="ocean">Ocean Deep</option>
					<option value="forest">Forest Trail</option>
					<option value="light">Light Mode</option>
					<option value="pinkpantheress">PinkPantheress</option>
				</select>
			</div>

			<div class="setting-row">
				<span>Visualizer:</span>
				<select id="visualizer-mode-select">
					<option value="bars">Frequency Bars</option>
					<option value="waveform">Waveform Line</option>
				</select>
			</div>

			<!-- NEW FEATURE: Skip Silence Setting -->
			<div class="setting-row">
				<span>Skip Silence:</span>
				<select id="skip-silence-select">
					<option value="false">Off</option>
					<option value="true">On</option>
				</select>
			</div>
		</div>

		<div id="file-not-found-alert" style="display: none;">
			üö® **Playback Warning:** Files were loaded from your last session, but the audio data is missing. Please
			re-add your files to play music.
		</div>

		<div id="file-input-container">
			<label id="file-label" for="mp3-upload">
				+ Add Audio Files
			</label>
			<!-- Updated accept attribute to allow all audio files -->
			<input type="file" id="mp3-upload" accept="audio/*" multiple>

			<button id="clear-playlist-btn" title="Remove all songs from playlist" disabled>
				Clear Playlist üóëÔ∏è
			</button>

			<button id="sort-playlist-btn" title="Sort playlist alphabetically (A-Z)" disabled>
				Sort (A-Z) ‚¨ÜÔ∏è
			</button>

			<div id="limit-message-wrapper">
				<div id="limit-message"></div>
			</div>
		</div>

		<div id="playlist-container">
			<div id="playlist-empty">Click the button above to add audio files from your computer.</div>
			<ul id="playlist">
			</ul>
		</div>


		<audio id="audio-player"></audio>

		<div id="controls-bar">

			<div id="main-control-area">

				<div id="track-info-container">
					<div id="album-art-container">
						<img id="album-art"
							src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
							style="opacity: 0.1;" alt="Album Art Placeholder">
					</div>
						<div id="track-details">
							<div id="current-track-display" class="empty">No Track Loaded</div>
							<div class="dashed-separator"></div>
						</div>
					</div>

					<div id="icon-block">
						<div id="mode-buttons">
							<button id="shuffle-btn" title="Shuffle Playlist (Off)">üîÄ</button>
							<button id="repeat-btn" title="Repeat (Off)" data-repeat-mode="off">üîÅ</button>
						</div>

						<div id="playback-buttons">
							<!-- NEW FEATURE: Skip Backward 10s -->
							<button id="skip-back-btn" title="Rewind 10 seconds" disabled>‚èÆÔ∏è</button>
							<button id="prev-btn" title="Previous Track" disabled><i class="fas fa-backward"></i></button>
							<button id="play-pause-btn" title="Play/Pause" disabled>‚ñ∂Ô∏è</button>
							<button id="next-btn" title="Next Track" disabled><i class="fas fa-forward"></i></button>
							<!-- NEW FEATURE: Skip Forward 10s -->
							<button id="skip-forward-btn" title="Forward 10 seconds" disabled>‚è≠Ô∏è</button>
						</div>
					</div>

					<div id="visualizer"></div>
					<div id="speed-controls">
						<button data-speed="0.5" class="speed-btn">0.5x</button>
						<button data-speed="1.0" class="speed-btn active">1.0x</button>
						<button data-speed="1.5" class="speed-btn">1.5x</button>
						<button data-speed="2.0" class="speed-btn">2.0x</button>
					</div>

				</div>

				<div id="seek-volume-row">
					<div id="seek-bar-container">
						<span id="current-time">0:00</span>
						<input type="range" id="seek-bar" value="0" min="0" max="100" disabled>
						<span id="total-duration">0:00</span>
					</div>

					<div id="volume-bar-container">
						<!-- NEW FEATURE: Mute Toggle Button -->
						<button id="mute-btn" title="Mute/Unmute" style="background: none; border: none; padding: 0; color: var(--text-color); font-size: 16px; cursor: pointer;">üîä</button>
						<input type="range" id="volume-bar" value="100" min="0" max="100">
				</div>
					</div>

				</div>

			</div>

			<script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>

			<script>
				// --- CONSTANTS ---
		const MAX_SONGS = 50;
		const REWIND_THRESHOLD = 2;
		const VISUALIZER_BAR_COUNT = 32;
		const ID3_SCAN_SIZE = 256 * 1024; // Scan first 256KB for ID3 tags
		const SKIP_SECONDS = 10; // For skip forward/backward buttons

		// --- SKIP SILENCE CONSTANTS ---
		const SILENCE_THRESHOLD = 5; // Average frequency value below which we consider it silent (0-255 scale)
		const SILENCE_TIME_MS = 500; // Time to advance playback when silence is detected.

		// ===============================================
		// --- DOM Elements ---
		// ===============================================
		const audioPlayer = document.getElementById('audio-player');
		const playlistElement = document.getElementById('playlist');
		const playlistEmpty = document.getElementById('playlist-empty');
		const mp3Upload = document.getElementById('mp3-upload');
		const playPauseBtn = document.getElementById('play-pause-btn');
		const prevBtn = document.getElementById('prev-btn');
		const nextBtn = document.getElementById('next-btn');
		const seekBar = document.getElementById('seek-bar');
		const currentTimeDisplay = document.getElementById('current-time');
		const totalDurationDisplay = document.getElementById('total-duration');
		const currentTrackDisplay = document.getElementById('current-track-display');
		const volumeBar = document.getElementById('volume-bar');
		const clearPlaylistBtn = document.getElementById('clear-playlist-btn');
		const visualizerContainer = document.getElementById('visualizer');
		const fileNotFoundAlert = document.getElementById('file-not-found-alert');
		const sortPlaylistBtn = document.getElementById('sort-playlist-btn');
		const speedControls = document.getElementById('speed-controls');
		const albumArt = document.getElementById('album-art');
		const limitMessage = document.getElementById('limit-message');

		// Settings elements
		const settingsBtn = document.getElementById('settings-btn');
		const settingsModal = document.getElementById('settings-modal');
		const themeSelect = document.getElementById('theme-select');
		const visualizerModeSelect = document.getElementById('visualizer-mode-select');
		const skipSilenceSelect = document.getElementById('skip-silence-select'); // NEW

		// Mode Buttons
		const shuffleBtn = document.getElementById('shuffle-btn');
		const repeatBtn = document.getElementById('repeat-btn');

		// NEW: Skip and Mute Buttons
		const skipBackBtn = document.getElementById('skip-back-btn');
		const skipForwardBtn = document.getElementById('skip-forward-btn');
		const muteBtn = document.getElementById('mute-btn');

		// Visualizer bar array (must be global/module scope)
		const visualizerBars = [];

		// --- Global State ---
		let playlistData = [];
		let currentTrackIndex = -1;
		let isPlaying = false;
		let repeatMode = 'off'; // 'off', 'one', 'all'
		let isShuffling = false;
		let currentPlaybackRate = 1.0;
		let shuffledOrder = [];

		let lastVolume = 1.0; // NEW: Store last non-zero volume for mute toggle
		let skipSilenceEnabled = false; // NEW: Skip silence toggle state

		// --- Web Audio State ---
		let audioContext = null;
		let analyser = null;
		let source = null;
		let bufferLength = 0;
		let dataArray = null;
		let animationFrameId = null;
		let visualizerCanvas = null;
		let canvasCtx = null;

		// --- Drag and Drop State ---
		let dragSrcEl = null;

		// ===============================================
		// --- UTILITY & PERSISTENCE FUNCTIONS ---
		// ===============================================

		function formatTime(seconds) {
			if (isNaN(seconds) || seconds < 0) return '0:00';
			const minutes = Math.floor(seconds / 60);
			const secs = Math.floor(seconds % 60);
			return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
		}

		function updateLimitMessage() {
			const remaining = MAX_SONGS - playlistData.length;
			limitMessage.textContent = `(${playlistData.length}/${MAX_SONGS} slots used)`;
			limitMessage.style.color = remaining <= 5 ? 'var(--warning-color)' : 'var(--light-gray)';

			clearPlaylistBtn.disabled = playlistData.length === 0;
			sortPlaylistBtn.disabled = playlistData.length < 2;
		}

		function arrayBufferToBase64(buffer) {
			let binary = '';
			const bytes = new Uint8Array(buffer);
			const len = bytes.byteLength;
			for (let i = 0; i < len; i++) {
				binary += String.fromCharCode(bytes[i]);
			}
			return btoa(binary);
		}

		function readID3Tags(file) {
			return new Promise((resolve) => {
				let title = file.name.replace(/\.[^/.]+$/, '').trim() || 'Unknown Track';
				let albumArtUrl = null;

				if (typeof window.jsmediatags === 'undefined') {
					return resolve({
						title,
						albumArtUrl
					});
				}

				window.jsmediatags.read(file, {
					onSuccess: function (tag) {
						const tags = tag.tags;
						if (tags.title) {
							title = tags.title.trim();
							if (tags.artist) {
								title = `${tags.artist.trim()} - ${title}`;
							}
						}

						if (tags.picture) {
							try {
								const picture = tags.picture;
								const base64String = arrayBufferToBase64(picture.data);
								albumArtUrl = `data:${picture.format};base64,${base64String}`;
							} catch (e) {
								console.error('Error processing album art:', e);
							}
						}

						resolve({
							title,
							albumArtUrl
						});
					},
					onError: function (error) {
						resolve({
							title,
							albumArtUrl
						});
					},
					readLimit: ID3_SCAN_SIZE
				});
			});
		}

		function getFileDuration(file, objectUrl) {
			return new Promise((resolve) => {
				const tempAudio = new Audio();
				tempAudio.preload = 'metadata';

				const timer = setTimeout(() => {
					resolve(0);
					URL.revokeObjectURL(objectUrl);
				}, 3000);

				tempAudio.onloadedmetadata = function () {
					clearTimeout(timer);
					resolve(tempAudio.duration);
				};
				tempAudio.onerror = function () {
					clearTimeout(timer);
					resolve(0);
				};
				tempAudio.src = objectUrl;
			});
		}

		// --- THEME & SETTINGS LOGIC ---
		function applyTheme(theme) {
			document.body.className = '';
			document.body.classList.add(`theme-${theme}`);
			currentTheme = theme;
		}

		function loadSettings() {
			const savedTheme = localStorage.getItem('playerTheme') || 'dracula';
			const savedVisualizer = localStorage.getItem('visualizerMode') || 'bars';
			const savedSilence = localStorage.getItem('skipSilenceEnabled') === 'true'; // NEW

			currentTheme = savedTheme;
			if (themeSelect) themeSelect.value = savedTheme;

			visualizerMode = savedVisualizer;
			if (visualizerModeSelect) visualizerModeSelect.value = savedVisualizer;

			skipSilenceEnabled = savedSilence; // NEW
			if (skipSilenceSelect) skipSilenceSelect.value = savedSilence.toString(); // NEW

			applyTheme(currentTheme);
		}

		function saveSettings() {
			localStorage.setItem('playerTheme', currentTheme);
			localStorage.setItem('visualizerMode', visualizerMode);
			localStorage.setItem('skipSilenceEnabled', skipSilenceEnabled); // NEW
		}

		// --- VISUALIZER LOGIC ---

		function setVisualizerMode(mode) {
			visualizerMode = mode;
			saveSettings();

			if (visualizerCanvas) {
				visualizerCanvas.style.display = (mode === 'waveform') ? 'block' : 'none';
			}
			document.querySelectorAll('.visualizer-bar').forEach(bar => {
				bar.style.display = (mode === 'bars') ? 'block' : 'none';
			});
		}

		function setupVisualizer() {
			if (!audioContext || audioContext.state === 'closed') {
				audioContext = new (window.AudioContext || window.webkitAudioContext)();
			}

			if (!analyser) {
				analyser = audioContext.createAnalyser();
			}

			if (!source) {
				source = audioContext.createMediaElementSource(audioPlayer);
				source.connect(analyser);
				analyser.connect(audioContext.destination);
			}

			if (audioContext.state === 'suspended') {
				audioContext.resume();
			}

			if (!visualizerCanvas) {
				visualizerCanvas = document.createElement('canvas');
				visualizerCanvas.id = 'visualizer-canvas';
				visualizerContainer.appendChild(visualizerCanvas);
				canvasCtx = visualizerCanvas.getContext('2d');
			}

			analyser.fftSize = 256;
			bufferLength = analyser.frequencyBinCount;
			dataArray = new Uint8Array(bufferLength);

			if (visualizerBars.length === 0) {
				for (let i = 0; i < VISUALIZER_BAR_COUNT; i++) {
					const bar = document.createElement('div');
					bar.className = 'visualizer-bar';
					visualizerContainer.appendChild(bar);
					visualizerBars.push(bar);
				}
			}

			setVisualizerMode(visualizerMode);

			if (!animationFrameId) {
				drawVisualizer();
			}
		}

		function checkAndSkipSilence() { // NEW FEATURE: Skip Silence Detection
			if (!skipSilenceEnabled || !analyser || !dataArray || audioPlayer.paused || audioPlayer.playbackRate !== 1.0) {
				return;
			}

			// Use frequency data to check loudness
			analyser.getByteFrequencyData(dataArray);

			let sum = 0;
			for (let i = 0; i < dataArray.length; i++) {
				sum += dataArray[i];
			}
			const average = sum / dataArray.length;

			if (average < SILENCE_THRESHOLD) {
				// Detected silence, skip forward
				audioPlayer.currentTime += (SILENCE_TIME_MS / 1000);
			}
		}

		function drawBars() {
			analyser.getByteFrequencyData(dataArray);
			const step = Math.floor(bufferLength / VISUALIZER_BAR_COUNT);

			for (let i = 0; i < VISUALIZER_BAR_COUNT; i++) {
				const amplitude = dataArray[i * step] || 0;
				const height = Math.max(1, amplitude * 30 / 255);
				visualizerBars[i].style.height = `${height}px`;
			}
		}

		function drawWaveform() {
			if (!canvasCtx || !visualizerCanvas) return;

			const rect = visualizerContainer.getBoundingClientRect();
			visualizerCanvas.width = rect.width;
			visualizerCanvas.height = rect.height;

			analyser.fftSize = 2048;
			const timeDomainBufferLength = analyser.fftSize;
			const timeDomainDataArray = new Uint8Array(timeDomainBufferLength);

			analyser.getByteTimeDomainData(timeDomainDataArray);

			canvasCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

			canvasCtx.lineWidth = 2;
			canvasCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--bright-green');

			canvasCtx.beginPath();

			const sliceWidth = visualizerCanvas.width * 1.0 / timeDomainBufferLength;
			let x = 0;

			for (let i = 0; i < timeDomainBufferLength; i++) {
				const v = timeDomainDataArray[i] / 128.0;
				const y = v * visualizerCanvas.height / 2;

				if (i === 0) {
					canvasCtx.moveTo(x, y);
				} else {
					canvasCtx.lineTo(x, y);
				}

				x += sliceWidth;
			}

			canvasCtx.lineTo(visualizerCanvas.width, visualizerCanvas.height / 2);
			canvasCtx.stroke();

			analyser.fftSize = 256;
		}

		function drawVisualizer() {
			animationFrameId = requestAnimationFrame(drawVisualizer);
			if (audioPlayer.paused || !analyser || audioContext?.state !== 'running') {
				if (visualizerMode === 'bars') {
					visualizerBars.forEach(bar => bar.style.height = '1px');
				} else if (visualizerMode === 'waveform' && canvasCtx && visualizerCanvas) {
					canvasCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
				}
				return;
			}

			checkAndSkipSilence(); // NEW: Skip Silence check integrated here

			if (visualizerMode === 'bars') {
				drawBars();
			} else if (visualizerMode === 'waveform') {
				drawWaveform();
			}
		}

		function initializeVisualizer() {
			if (visualizerBars.length === 0) {
				for (let i = 0; i < VISUALIZER_BAR_COUNT; i++) {
					const bar = document.createElement('div');
					bar.className = 'visualizer-bar';
					visualizerContainer.appendChild(bar);
					visualizerBars.push(bar);
				}
			}
			if (!visualizerCanvas) {
				visualizerCanvas = document.createElement('canvas');
				visualizerCanvas.id = 'visualizer-canvas';
				visualizerContainer.appendChild(visualizerCanvas);
				canvasCtx = visualizerCanvas.getContext('2d');
			}
			setVisualizerMode(visualizerMode);
			drawVisualizer();
		}

		// --- PERSISTENCE LOGIC (Updated to include current time) ---
		function savePlaylistState(includeTime = false) {
			const playlistMetadata = playlistData.map(file => ({
				name: file.name,
				duration: file.duration || 0,
				albumArtUrl: file.albumArtUrl || null,
				ready: file.ready || false
			}));

			localStorage.setItem('playlistData', JSON.stringify(playlistMetadata));
			localStorage.setItem('currentTrackIndex', currentTrackIndex.toString());
			localStorage.setItem('isShuffling', isShuffling);
			localStorage.setItem('repeatMode', repeatMode);
			localStorage.setItem('playerRate', currentPlaybackRate);

			// NEW FEATURE: Save playback position
			if (includeTime && currentTrackIndex !== -1 && audioPlayer.currentTime > 0) {
				localStorage.setItem('playbackPosition', audioPlayer.currentTime.toString());
			} else {
				localStorage.removeItem('playbackPosition');
			}
		}

		function loadPlaylistState() {
			const savedData = localStorage.getItem('playlistData');
			const savedIndex = localStorage.getItem('currentTrackIndex');
			const savedShuffle = localStorage.getItem('isShuffling');
			const savedRepeat = localStorage.getItem('repeatMode');
			const savedRate = localStorage.getItem('playerRate');

			if (!savedData) return;

			try {
				const metadata = JSON.parse(savedData) || [];

				playlistData = metadata.map(item => ({
					name: item.name,
					duration: item.duration || 0,
					albumArtUrl: item.albumArtUrl || null,
					ready: false,
					objectUrl: null,
					file: null
				}));

				currentTrackIndex = savedIndex ? parseInt(savedIndex, 10) : -1;
				isShuffling = savedShuffle === 'true';
				repeatMode = savedRepeat || 'off';
				currentPlaybackRate = savedRate ? parseFloat(savedRate) : 1.0;
				audioPlayer.playbackRate = currentPlaybackRate;

				if (isShuffling) {
					shuffledOrder = generateShuffledOrder();
				}

				renderPlaylist();
				updateSpeedControls();
				updateShuffleButton();
				updateRepeatButton();

				const hasPlaceholders = playlistData.some(f => !f.ready);
				showFileNotFoundAlert(hasPlaceholders);

				if (currentTrackIndex !== -1 && playlistData[currentTrackIndex]) {
					loadTrack(currentTrackIndex, false);
				} else {
					updateControlButtons();
				}

			} catch (e) {
				console.error("Error loading playlist state:", e);
			}
		}

		// --- ALERT FUNCTION ---
		function showFileNotFoundAlert(show) {
			fileNotFoundAlert.style.display = show ? 'block' : 'none';
		}

		// --- CONTROL FUNCTIONS (Updated to include new skip buttons) ---
		function updateControlButtons() {
			const enable = playlistData.length > 0;
			playPauseBtn.disabled = !enable;
			prevBtn.disabled = !enable;
			nextBtn.disabled = !enable;
			seekBar.disabled = !enable;
			skipBackBtn.disabled = !enable; // NEW
			skipForwardBtn.disabled = !enable; // NEW
		}

		function updateShuffleButton() {
			shuffleBtn.classList.toggle('active', isShuffling);
			shuffleBtn.title = isShuffling ? "Shuffle Playlist (On)" : "Shuffle Playlist (Off)";
		}

		function updateRepeatButton() {
			let icon = 'üîÅ';
			let title = 'Repeat (Off)';

			repeatBtn.classList.remove('active', 'one');

			if (repeatMode === 'all') {
				repeatBtn.classList.add('active');
				title = 'Repeat Playlist (On)';
				icon = 'üîÅ';
			} else if (repeatMode === 'one') {
				repeatBtn.classList.add('active', 'one');
				title = 'Repeat One Track (On)';
				icon = 'üîÇ';
			}
			repeatBtn.textContent = icon;
			repeatBtn.title = title;
			repeatBtn.dataset.repeatMode = repeatMode;
		}

		function setRepeatMode(mode) {
			repeatMode = mode;
			updateRepeatButton();
			localStorage.setItem('repeatMode', mode);
		}

		function updateSpeedControls() {
			document.querySelectorAll('#speed-controls .speed-btn').forEach(btn => {
				btn.classList.remove('active');
			});
			const activeBtn = document.querySelector(`#speed-controls button[data-speed="${currentPlaybackRate.toFixed(1)}"]`);
			if (activeBtn) activeBtn.classList.add('active');
		}

		// --- SHUFFLE LOGIC (Unchanged) ---
		function generateShuffledOrder() {
			let order = Array.from({
				length: playlistData.length
			}, (_, i) => i);
			for (let i = order.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[order[i], order[j]] = [order[j], order[i]];
			}
			return order;
		}

		function getNextShuffledIndex() {
			if (shuffledOrder.length === 0 || playlistData.length !== shuffledOrder.length) {
				shuffledOrder = generateShuffledOrder();
			}

			let currentIndexInShuffled = shuffledOrder.findIndex(index => index === currentTrackIndex);

			if (currentIndexInShuffled === -1) {
				return shuffledOrder[0] || -1;
			}

			let nextIndexInShuffled = (currentIndexInShuffled + 1) % shuffledOrder.length;

			if (nextIndexInShuffled === 0 && repeatMode === 'off') {
				return -1;
			}

			return shuffledOrder[nextIndexInShuffled];
		}

		function getPrevShuffledIndex() {
			if (shuffledOrder.length === 0 || playlistData.length !== shuffledOrder.length) {
				shuffledOrder = generateShuffledOrder();
			}

			let currentIndexInShuffled = shuffledOrder.findIndex(index => index === currentTrackIndex);
			if (currentIndexInShuffled === -1) {
				return shuffledOrder[0] || -1;
			}

			let prevIndexInShuffled = (currentIndexInShuffled - 1 + shuffledOrder.length) % shuffledOrder.length;
			return shuffledOrder[prevIndexInShuffled];
		}


		// --- PLAYBACK FUNCTIONS (Updated for persistence) ---

		function loadTrack(index, shouldPlay = false) {
			savePlaylistState(); // Save current track index and modes

			if (index < 0 || index >= playlistData.length) {
				currentTrackIndex = -1;
				audioPlayer.src = '';
				currentTrackDisplay.textContent = 'No Track Loaded';
				currentTrackDisplay.classList.add('empty');
				totalDurationDisplay.textContent = '0:00';
				seekBar.value = 0;
				updateControlButtons();
				albumArt.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
				albumArt.style.opacity = '0.1';
				return;
			}

			currentTrackIndex = index;
			const track = playlistData[currentTrackIndex];

			currentTimeDisplay.textContent = '0:00';
			totalDurationDisplay.textContent = formatTime(track.duration || 0);
			seekBar.max = track.duration || 0;
			seekBar.value = 0;

			document.querySelectorAll('.track-item').forEach((item, i) => {
				item.classList.toggle('active', i === currentTrackIndex);
			});

			currentTrackDisplay.textContent = track.name;
			currentTrackDisplay.classList.remove('empty');
			updateControlButtons();

			const artUrl = track.albumArtUrl || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
			albumArt.src = artUrl;
			albumArt.style.opacity = track.albumArtUrl ? '1' : '0.1';

			if (track.ready && track.objectUrl) {
				audioPlayer.src = track.objectUrl;
				audioPlayer.playbackRate = currentPlaybackRate;
			} else {
				audioPlayer.src = '';
				audioPlayer.pause();
				isPlaying = false;
				playPauseBtn.textContent = '‚ñ∂Ô∏è';
			}

			// NEW FEATURE: Persistent Playback Position Logic
			const savedPosition = localStorage.getItem('playbackPosition');

			if (track.ready && savedPosition && parseFloat(savedPosition) > 0) {
				const position = parseFloat(savedPosition);
				// Must wait for metadata to load before setting currentTime
				audioPlayer.onloadedmetadata = function() {
					if (audioPlayer.readyState >= 2) {
						audioPlayer.currentTime = position;
						currentTimeDisplay.textContent = formatTime(position);
						localStorage.removeItem('playbackPosition'); // Use once, then clear
						audioPlayer.onloadedmetadata = null; // Clean up listener
						if (shouldPlay) {
							audioPlayer.play().catch(console.error);
						}
					}
				};
			}

			if (shouldPlay && track.ready) {
				setupVisualizer();
				// Only auto-play if no position was restored via onloadedmetadata
				if (!savedPosition || parseFloat(savedPosition) === 0) {
					audioPlayer.play().catch(error => {
						console.error("Autoplay failed:", error);
					});
				}
			}
		}

		function togglePlayPause() {
			if (playlistData.length === 0) return;

			if (currentTrackIndex === -1) {
				loadTrack(0, true);
				return;
			}

			const currentTrack = playlistData[currentTrackIndex];
			if (!currentTrack.ready) {
				console.error("Cannot play: File data not available for:", currentTrack.name);
				return;
			}

			if (isPlaying) {
				audioPlayer.pause();
			} else {
				setupVisualizer();
				audioPlayer.play().catch(error => {
					console.error("Autoplay failed:", error);
				});
			}
		}

		function playNextTrack() {
			if (playlistData.length === 0) return;

			if (repeatMode === 'one' && audioPlayer.currentTime > 0) {
				audioPlayer.currentTime = 0;
				audioPlayer.play();
				return;
			}

			let nextIndex;

			if (isShuffling) {
				nextIndex = getNextShuffledIndex();
			} else {
				nextIndex = (currentTrackIndex + 1);
				if (nextIndex >= playlistData.length) {
					if (repeatMode === 'all') {
						nextIndex = 0;
					} else {
						audioPlayer.pause();
						isPlaying = false;
						playPauseBtn.textContent = '‚ñ∂Ô∏è';
						audioPlayer.currentTime = 0;
						loadTrack(0, false);
						return;
					}
				}
			}

			if (nextIndex !== -1) {
				loadTrack(nextIndex, true);
			} else {
				audioPlayer.pause();
				isPlaying = false;
				playPauseBtn.textContent = '‚ñ∂Ô∏è';
				audioPlayer.currentTime = 0;
				loadTrack(currentTrackIndex, false);
			}
		}

		function playPrevTrack() {
			if (playlistData.length === 0) return;

			if (audioPlayer.currentTime > REWIND_THRESHOLD && !isShuffling) {
				audioPlayer.currentTime = 0;
			} else {
				let prevIndex;
				if (isShuffling) {
					prevIndex = getPrevShuffledIndex();
				} else {
					prevIndex = (currentTrackIndex - 1 + playlistData.length) % playlistData.length;
				}
				loadTrack(prevIndex, true);
			}
		}

		function setPlaybackSpeed(rate) {
			currentPlaybackRate = rate;
			audioPlayer.playbackRate = rate;
			updateSpeedControls();
			localStorage.setItem('playerRate', rate);
		}

		// NEW FEATURE: Skip 10s Backward
		function skipBackward(seconds) {
			if (playlistData.length === 0) return;
			audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - seconds);
		}

		// NEW FEATURE: Skip 10s Forward
		function skipForward(seconds) {
			if (playlistData.length === 0) return;
			audioPlayer.currentTime = Math.min(audioPlayer.duration || Infinity, audioPlayer.currentTime + seconds);
		}
		
		// NEW FEATURE: Mute/Unmute
		function toggleMute() {
			if (audioPlayer.volume > 0) {
				lastVolume = audioPlayer.volume;
				audioPlayer.volume = 0;
				volumeBar.value = 0;
				muteBtn.textContent = 'üîá';
			} else {
				const restoreVolume = Math.max(0.1, lastVolume); // Restore, minimum 10%
				audioPlayer.volume = restoreVolume;
				volumeBar.value = restoreVolume * 100;
				muteBtn.textContent = 'üîä';
			}
			localStorage.setItem('playerVolume', volumeBar.value);
		}


		// --- PLAYLIST MANAGEMENT FUNCTIONS ---
		function clearPlaylist() {
			const modal = document.createElement('div');
			modal.style.cssText = "position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 2000;";
			modal.innerHTML = `
                <div style="background: var(--card-color); color: var(--text-color); padding: 30px; border-radius: var(--border-radius); box-shadow: 0 5px 15px rgba(0,0,0,0.5); max-width: 400px; text-align: center;">
                    <p style="margin-bottom: 20px;">Are you sure you want to clear the entire playlist? This cannot be undone.</p>
                    <button id="confirm-yes" style="background: var(--warning-color); color: white; padding: 10px 20px; border: none; border-radius: 4px; margin-right: 10px; cursor: pointer;">Yes, Clear</button>
                    <button id="confirm-no" style="background: var(--light-gray); color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
                </div>
            `;
			document.body.appendChild(modal);

			modal.querySelector('#confirm-yes').onclick = () => {
				playlistData.forEach(track => {
					if (track.objectUrl) URL.revokeObjectURL(track.objectUrl);
				});

				playlistData = [];
				currentTrackIndex = -1;
				audioPlayer.pause();
				audioPlayer.src = '';
				isPlaying = false;

				renderPlaylist();
				updateLimitMessage();
				loadTrack(-1);

				localStorage.removeItem('playlistData');
				localStorage.removeItem('currentTrackIndex');
				localStorage.removeItem('playbackPosition'); // Clear persistent position
				showFileNotFoundAlert(false);
				modal.remove();
			};
			modal.querySelector('#confirm-no').onclick = () => {
				modal.remove();
			};
		}

		function removeTrack(index) {
			if (index < 0 || index >= playlistData.length) return;

			const trackToRemove = playlistData[index];
			if (trackToRemove.objectUrl) {
				URL.revokeObjectURL(trackToRemove.objectUrl);
			}

			let nextIndex = -1;

			if (index === currentTrackIndex) {
				audioPlayer.pause();
				isPlaying = false;

				if (playlistData.length > 1) {
					nextIndex = index % (playlistData.length - 1);
				}
			} else if (index < currentTrackIndex) {
				currentTrackIndex--;
			}

			playlistData.splice(index, 1);

			if (playlistData.length === 0) {
				loadTrack(-1);
			} else if (nextIndex !== -1) {
				loadTrack(nextIndex, true);
			}

			if (isShuffling) {
				shuffledOrder = generateShuffledOrder();
			}

			renderPlaylist();
			updateLimitMessage();
			savePlaylistState();
		}

		function sortPlaylist() {
			if (playlistData.length < 2) return;

			const currentTrackName = currentTrackIndex !== -1 ? playlistData[currentTrackIndex].name : null;

			playlistData.sort((a, b) => a.name.localeCompare(b.name));

			if (currentTrackName) {
				currentTrackIndex = playlistData.findIndex(track => track.name === currentTrackName);
			} else {
				currentTrackIndex = -1;
			}

			if (isShuffling) {
				shuffledOrder = generateShuffledOrder();
			}

			renderPlaylist();
			savePlaylistState();
		}

		function renderPlaylist() {
			playlistElement.innerHTML = '';
			playlistEmpty.style.display = playlistData.length === 0 ? 'block' : 'none';

			let hasPlaceholders = false;

			playlistData.forEach((track, index) => {
				const li = document.createElement('li');
				li.className = 'track-item';
				li.setAttribute('data-index', index);
				li.draggable = true;

				if (index === currentTrackIndex) {
					li.classList.add('active');
				}

				if (!track.ready) hasPlaceholders = true;

				const durationText = formatTime(track.duration || 0);

				li.innerHTML = `
                    <div class="track-item-left" title="${track.ready ? 'Click to play' : 'File missing, re-add audio file'}" data-index="${index}">
                        <div class="ready-indicator ${track.ready ? 'ready' : ''}"></div>
                        <div class="track-name" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                            ${track.name}
                        </div>
                    </div>
                    <span class="track-duration">${durationText}</span>
                    <button class="remove-btn" title="Remove track" data-index="${index}">‚úñ</button>
                `;

				li.querySelector('.track-item-left').addEventListener('click', () => {
					if (index !== currentTrackIndex || !isPlaying) {
						loadTrack(index, true);
					} else {
						togglePlayPause();
					}
				});

				li.querySelector('.remove-btn').addEventListener('click', (e) => {
					e.stopPropagation();
					removeTrack(index);
				});

				playlistElement.appendChild(li);
			});

			showFileNotFoundAlert(hasPlaceholders);
		}

		// --- DRAG AND DROP LOGIC (Unchanged) ---
		function handleDragStart(e) {
			dragSrcEl = e.target;
			e.dataTransfer.effectAllowed = 'move';
			e.dataTransfer.setData('text/plain', e.target.dataset.index);
			setTimeout(() => {
				dragSrcEl.classList.add('dragging');
			}, 0);
		}

		function handleDragOverIndicator(e) {
			e.preventDefault();
			e.dataTransfer.dropEffect = 'move';

			const target = e.target.closest('.track-item');
			if (!target || target === dragSrcEl) return;

			document.querySelectorAll('.track-item').forEach(item => {
				item.classList.remove('drag-over-top', 'drag-over-bottom');
			});

			const rect = target.getBoundingClientRect();
			const y = e.clientY - rect.top;

			if (y < rect.height / 2) {
				target.classList.add('drag-over-top');
			} else {
				target.classList.add('drag-over-bottom');
			}
		}

		function handleDragEnter(e) {
			e.preventDefault();
		}

		function handleDragLeave(e) {
			e.target.closest('.track-item')?.classList.remove('drag-over-top', 'drag-over-bottom');
		}

		function handleDrop(e) {
			e.preventDefault();

			const targetEl = e.target.closest('.track-item');
			if (!targetEl || targetEl === dragSrcEl) return;

			const dragIndex = parseInt(e.dataTransfer.getData('text/plain'));
			const dropIndex = parseInt(targetEl.dataset.index);

			let newIndex = dropIndex;
			if (targetEl.classList.contains('drag-over-bottom')) {
				newIndex = dropIndex + 1;
			}

			const draggedTrack = playlistData.splice(dragIndex, 1)[0];
			playlistData.splice(newIndex > dragIndex ? newIndex - 1 : newIndex, 0, draggedTrack);

			if (currentTrackIndex === dragIndex) {
				currentTrackIndex = newIndex > dragIndex ? newIndex - 1 : newIndex;
			} else if (dragIndex < currentTrackIndex && newIndex > currentTrackIndex) {
				currentTrackIndex--;
			} else if (dragIndex > currentTrackIndex && newIndex <= currentTrackIndex) {
				currentTrackIndex++;
			}

			if (isShuffling) {
				shuffledOrder = generateShuffledOrder();
			}

			renderPlaylist();
			savePlaylistState();
		}

		function handleDragEnd(e) {
			dragSrcEl.classList.remove('dragging');
			document.querySelectorAll('.track-item').forEach(item => {
				item.classList.remove('drag-over-top', 'drag-over-bottom');
			});
			dragSrcEl = null;
		}

		function attachDragAndDropListeners() {
			playlistElement.addEventListener('dragstart', handleDragStart);
			playlistElement.addEventListener('dragover', handleDragOverIndicator);
			playlistElement.addEventListener('dragenter', handleDragEnter);
			playlistElement.addEventListener('dragleave', handleDragLeave);
			playlistElement.addEventListener('drop', handleDrop);
			playlistElement.addEventListener('dragend', handleDragEnd);
		}

		// --- EVENT HANDLERS ---

		async function handleFileSelection(e) {
			const files = Array.from(e.target.files);

			const filesToAdd = files.filter(file =>
				file.type.startsWith('audio/') &&
				playlistData.length < MAX_SONGS
			);

			let shouldStartPlaying = playlistData.length === 0;
			let firstNewTrackIndex = -1;

			for (const file of filesToAdd) {

				const objectUrl = URL.createObjectURL(file);
				const duration = await getFileDuration(file, objectUrl);
				const {
					title,
					albumArtUrl
				} = await readID3Tags(file);

				const newTrack = {
					name: title,
					objectUrl: objectUrl,
					duration: duration,
					albumArtUrl: albumArtUrl,
					ready: true,
					file: file
				};

				const existingIndex = playlistData.findIndex(track => track.file?.name === file.name || track.name === title);

				if (existingIndex !== -1) {
					if (playlistData[existingIndex].objectUrl) {
						URL.revokeObjectURL(playlistData[existingIndex].objectUrl);
					}
					playlistData[existingIndex] = newTrack;
					if (existingIndex === currentTrackIndex) {
						loadTrack(currentTrackIndex, isPlaying);
					}
				} else {
					playlistData.push(newTrack);
					if (firstNewTrackIndex === -1) {
						firstNewTrackIndex = playlistData.length - 1;
					}
				}
			}

			e.target.value = '';

			renderPlaylist();
			updateLimitMessage();
			savePlaylistState();

			if (isShuffling) {
				shuffledOrder = generateShuffledOrder();
			}

			if (shouldStartPlaying && firstNewTrackIndex !== -1) {
				loadTrack(firstNewTrackIndex, true);
			}
		}

		function handleKeyboardControls(e) {
			if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
				return;
			}

			switch (e.key) {
				case ' ': // Spacebar
					e.preventDefault();
					if (!playPauseBtn.disabled) {
						togglePlayPause();
					}
					break;
				case 'ArrowLeft': // Left Arrow (Rewind 10s)
					e.preventDefault();
					if (!skipBackBtn.disabled) {
						skipBackward(SKIP_SECONDS);
					}
					break;
				case 'ArrowRight': // Right Arrow (Forward 10s)
					e.preventDefault();
					if (!skipForwardBtn.disabled) {
						skipForward(SKIP_SECONDS);
					}
					break;
				default:
					return;
			}
		}

		// --- INITIALIZATION ---
		document.addEventListener('DOMContentLoaded', () => {
			loadSettings();
			loadPlaylistState();
			updateLimitMessage();

			// Restore volume on load
			const savedVolume = localStorage.getItem('playerVolume');
			if (savedVolume !== null) {
				audioPlayer.volume = parseFloat(savedVolume) / 100;
				volumeBar.value = savedVolume;
				// Set initial mute state
				if (parseFloat(savedVolume) === 0) {
					muteBtn.textContent = 'üîá';
				} else {
					lastVolume = parseFloat(savedVolume) / 100;
				}
			}

			initializeVisualizer();
			attachDragAndDropListeners();

			// --- ATTACH ALL LISTENERS ---

			// System Listeners
			mp3Upload.addEventListener('change', handleFileSelection);
			clearPlaylistBtn.addEventListener('click', clearPlaylist);
			sortPlaylistBtn.addEventListener('click', sortPlaylist);
			document.addEventListener('keydown', handleKeyboardControls);
			window.addEventListener('beforeunload', () => {
				savePlaylistState(true); // NEW: Save current time on exit
			});


			// Playback Buttons
			playPauseBtn.addEventListener('click', togglePlayPause);
			prevBtn.addEventListener('click', playPrevTrack);
			nextBtn.addEventListener('click', playNextTrack);
			skipBackBtn.addEventListener('click', () => skipBackward(SKIP_SECONDS)); // NEW
			skipForwardBtn.addEventListener('click', () => skipForward(SKIP_SECONDS)); // NEW
			muteBtn.addEventListener('click', toggleMute); // NEW

			// Mode Buttons
			shuffleBtn.addEventListener('click', () => {
				isShuffling = !isShuffling;
				updateShuffleButton();
				localStorage.setItem('isShuffling', isShuffling);
				if (isShuffling) {
					shuffledOrder = generateShuffledOrder();
				}
			});

			repeatBtn.addEventListener('click', () => {
				const modes = ['off', 'all', 'one'];
				const currentIndex = modes.indexOf(repeatMode);
				const nextIndex = (currentIndex + 1) % modes.length;
				setRepeatMode(modes[nextIndex]);
			});

			// Speed Control Listeners
			speedControls.addEventListener('click', (e) => {
				if (e.target.classList.contains('speed-btn')) {
					const speed = parseFloat(e.target.dataset.speed);
					if (!isNaN(speed)) {
						setPlaybackSpeed(speed);
					}
				}
			});

			// Settings Event Listeners
			settingsBtn.addEventListener('click', () => {
				settingsModal.classList.toggle('open');
				settingsModal.style.display = settingsModal.classList.contains('open') ? 'block' : 'none';
			});

			themeSelect.addEventListener('change', (e) => {
				applyTheme(e.target.value);
				saveSettings();
			});

			visualizerModeSelect.addEventListener('change', (e) => {
				setVisualizerMode(e.target.value);
			});
			
			// NEW: Skip Silence Setting Listener
			skipSilenceSelect.addEventListener('change', (e) => {
				skipSilenceEnabled = e.target.value === 'true';
				saveSettings();
			});


			// Audio events
			audioPlayer.addEventListener('play', () => {
				isPlaying = true;
				playPauseBtn.textContent = '‚è∏Ô∏è';
				localStorage.removeItem('playbackPosition'); // Clear position once playback starts
			});

			audioPlayer.addEventListener('pause', () => {
				isPlaying = false;
				playPauseBtn.textContent = '‚ñ∂Ô∏è';
				savePlaylistState(true); // Save current time on pause
			});

			audioPlayer.addEventListener('timeupdate', () => {
				currentTimeDisplay.textContent = formatTime(audioPlayer.currentTime);
				if (audioPlayer.duration) {
					seekBar.max = audioPlayer.duration;
					// Update seek bar only if the user isn't actively scrubbing
					if (document.activeElement !== seekBar) {
						seekBar.value = audioPlayer.currentTime;
					}
				}
			});

			audioPlayer.addEventListener('ended', () => {
				if (repeatMode === 'one') {
					audioPlayer.currentTime = 0;
					audioPlayer.play();
				} else {
					playNextTrack();
				}
			});

			// Seek Bar (Scrubbing)
			seekBar.addEventListener('input', () => {
				currentTimeDisplay.textContent = formatTime(seekBar.value);
			});

			seekBar.addEventListener('change', () => {
				audioPlayer.currentTime = seekBar.value;
				savePlaylistState();
			});

			// Volume Bar
			volumeBar.addEventListener('input', () => {
				const volume = volumeBar.value / 100;
				audioPlayer.volume = volume;
				lastVolume = volume > 0 ? volume : lastVolume; // Update last volume if it's not zero
				muteBtn.textContent = volume > 0 ? 'üîä' : 'üîá';
			});

			volumeBar.addEventListener('change', () => {
				localStorage.setItem('playerVolume', volumeBar.value);
			});
		});
			</script>
</body>

</html></body><html>


